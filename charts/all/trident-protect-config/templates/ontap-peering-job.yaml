{{- if .Values.tridentProtect.ontapPeering.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: ontap-peering-{{ .Release.Revision }}
  namespace: trident-protect
  annotations:
    argocd.argoproj.io/sync-wave: "3"
    argocd.argoproj.io/hook: Sync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 600
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: ontap-peering
      containers:
        - name: ontap-peering
          image: {{ .Values.tridentProtect.ontapPeering.image }}
          command: ["/bin/sh", "-c"]
          args:
            - |
              set -e

              ONTAP_USER=$(cat /credentials/username)
              ONTAP_PASS=$(cat /credentials/password)
              AUTH="${ONTAP_USER}:${ONTAP_PASS}"

              LOCAL_CLUSTER_MGMT="{{ .Values.tridentFSX.clusterLIF }}"
              LOCAL_SVM="{{ .Values.tridentFSX.svm }}"
              REMOTE_SVM="{{ .Values.tridentFSX.peer.svm }}"
              REMOTE_IC_IPS='{{ .Values.tridentFSX.peer.interclusterIPs | toJson }}'
              NAMESPACE="trident-protect"
              CM_NAME="ontap-peering-status"

              api() {
                curl -sk -u "${AUTH}" -H "Content-Type: application/json" "$@"
              }

              update_status_cm() {
                CLUSTER_STATE="$1"
                SVM_STATE="$2"
                PEER_NAME_VAL="${3:-}"
                MSG="${4:-}"
                TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

                cat <<CMEOF | curl -sk \
                  -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
                  -H "Content-Type: application/json" \
                  --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
                  -X PUT \
                  "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/configmaps/${CM_NAME}" \
                  -d @- > /dev/null 2>&1
              {
                "apiVersion": "v1",
                "kind": "ConfigMap",
                "metadata": {
                  "name": "${CM_NAME}",
                  "namespace": "${NAMESPACE}",
                  "labels": {
                    "app.kubernetes.io/component": "ontap-peering",
                    "app.kubernetes.io/managed-by": "ontap-peering-job"
                  }
                },
                "data": {
                  "clusterPeeringState": "${CLUSTER_STATE}",
                  "svmPeeringState": "${SVM_STATE}",
                  "peerClusterName": "${PEER_NAME_VAL}",
                  "localSVM": "${LOCAL_SVM}",
                  "remoteSVM": "${REMOTE_SVM}",
                  "message": "${MSG}",
                  "lastUpdated": "${TIMESTAMP}"
                }
              }
              CMEOF
              }

              echo "============================================"
              echo "  ONTAP Cluster & SVM Peering (local side)"
              echo "============================================"
              echo "  Local cluster mgmt: ${LOCAL_CLUSTER_MGMT}"
              echo "  Local SVM:          ${LOCAL_SVM}"
              echo "  Remote SVM:         ${REMOTE_SVM}"
              echo "  Remote IC IPs:      ${REMOTE_IC_IPS}"
              echo "============================================"

              CLUSTER_PEERS_URL="https://${LOCAL_CLUSTER_MGMT}/api/cluster/peers?fields=status,name,uuid"
              SVM_PEERS_URL="https://${LOCAL_CLUSTER_MGMT}/api/svm/peers?fields=state,svm,peer"

              update_status_cm "initializing" "pending" "" "Peering job starting"

              # ---- Step 1: Cluster Peering (local side only) ----
              echo ""
              echo "--- Checking cluster peering ---"
              PEERS=$(api "${CLUSTER_PEERS_URL}")
              PEER_COUNT=$(echo "${PEERS}" | jq '.num_records // 0')

              if [ "${PEER_COUNT}" -gt 0 ]; then
                echo "Cluster peering already exists (${PEER_COUNT} peer(s))."
              else
                PASSPHRASE="${ONTAP_PASS}"

                echo "Creating cluster peer on local FSx (${LOCAL_CLUSTER_MGMT})..."
                update_status_cm "creating" "pending" "" "Creating cluster peer"
                RESP=$(api -X POST "https://${LOCAL_CLUSTER_MGMT}/api/cluster/peers" \
                  -d "{\"remote\":{\"ip_addresses\":${REMOTE_IC_IPS}},\"authentication\":{\"passphrase\":\"${PASSPHRASE}\"}}" \
                  -w "\n%{http_code}" 2>/dev/null)
                HTTP=$(echo "${RESP}" | tail -1)
                BODY=$(echo "${RESP}" | sed '$d')
                echo "  HTTP ${HTTP}"
                if [ "${HTTP}" -ge 400 ]; then
                  ERR_MSG=$(echo "${BODY}" | jq -r '.error.message // "unknown"')
                  echo "  Error: ${ERR_MSG}"
                  update_status_cm "error" "pending" "" "Cluster peer creation failed: ${ERR_MSG}"
                fi

                echo "Waiting for peer cluster to configure its side..."
                sleep 15
              fi

              # ---- Step 2: Wait for peering to become available ----
              echo ""
              echo "--- Verifying cluster peering ---"
              echo "  (Peering completes once both clusters have configured their side)"
              RETRIES=0
              while [ ${RETRIES} -lt 30 ]; do
                PEERS=$(api "${CLUSTER_PEERS_URL}")
                PEER_COUNT=$(echo "${PEERS}" | jq '.num_records // 0')
                if [ "${PEER_COUNT}" -eq 0 ]; then
                  echo "  No peers yet (waiting for local creation to propagate...)"
                  RETRIES=$((RETRIES + 1))
                  sleep 10
                  continue
                fi
                PEER_STATE=$(echo "${PEERS}" | jq -r '.records[0].status.state // "unknown"')
                if [ "${PEER_STATE}" = "available" ]; then
                  break
                fi
                echo "  Peer state: ${PEER_STATE} (waiting for remote side...)"
                update_status_cm "${PEER_STATE}" "pending" "" "Waiting for remote cluster to peer"
                RETRIES=$((RETRIES + 1))
                sleep 10
              done

              PEER_UUID=$(echo "${PEERS}" | jq -r '.records[0].uuid // empty')
              PEER_NAME=$(echo "${PEERS}" | jq -r '.records[0].name // empty')
              PEER_STATE=$(echo "${PEERS}" | jq -r '.records[0].status.state // "unknown"')
              echo "  Cluster peer: ${PEER_NAME} (${PEER_UUID}) - state: ${PEER_STATE}"

              if [ -z "${PEER_UUID}" ]; then
                echo "ERROR: No cluster peer found."
                update_status_cm "error" "pending" "" "No cluster peer found after creation"
                exit 1
              fi

              if [ "${PEER_STATE}" != "available" ]; then
                echo "WARNING: Cluster peer not yet available (state: ${PEER_STATE})."
                echo "  The remote cluster Job may not have run yet."
                echo "  SVM peering will be attempted on next sync."
                update_status_cm "${PEER_STATE}" "pending" "${PEER_NAME}" "Waiting for remote cluster"
                exit 0
              fi

              update_status_cm "available" "pending" "${PEER_NAME}" "Cluster peered, creating SVM peer"

              # ---- Step 3: SVM Peering ----
              echo ""
              echo "--- Checking SVM peering ---"
              SVM_PEERS=$(api "${SVM_PEERS_URL}")
              SVM_PEER_COUNT=$(echo "${SVM_PEERS}" | jq '.num_records // 0')

              if [ "${SVM_PEER_COUNT}" -gt 0 ]; then
                SVM_STATE=$(echo "${SVM_PEERS}" | jq -r '.records[0].state // "unknown"')
                echo "SVM peering already exists (${SVM_PEER_COUNT} peer(s)), state: ${SVM_STATE}."
                update_status_cm "available" "${SVM_STATE}" "${PEER_NAME}" "Peering established"
              else
                SVM_PEER_ALIAS="${REMOTE_SVM}"
                if [ "${LOCAL_SVM}" = "${REMOTE_SVM}" ]; then
                  SVM_PEER_ALIAS="${REMOTE_SVM}-${PEER_NAME}"
                  echo "  Local and remote SVM names are identical (${LOCAL_SVM})"
                  echo "  Using peer alias: ${SVM_PEER_ALIAS}"
                fi

                echo "Creating SVM peer: ${LOCAL_SVM} <-> ${REMOTE_SVM} (alias: ${SVM_PEER_ALIAS})..."
                RESP=$(api -X POST "https://${LOCAL_CLUSTER_MGMT}/api/svm/peers" \
                  -d "{\"name\":\"${SVM_PEER_ALIAS}\",\"svm\":{\"name\":\"${LOCAL_SVM}\"},\"peer\":{\"cluster\":{\"uuid\":\"${PEER_UUID}\"},\"svm\":{\"name\":\"${REMOTE_SVM}\"}},\"applications\":[\"snapmirror\"]}" \
                  -w "\n%{http_code}" 2>/dev/null)
                HTTP=$(echo "${RESP}" | tail -1)
                BODY=$(echo "${RESP}" | sed '$d')
                echo "  HTTP ${HTTP}"
                if [ "${HTTP}" -ge 400 ]; then
                  ERR_MSG=$(echo "${BODY}" | jq -r '.error.message // "unknown"')
                  echo "  Error: ${ERR_MSG}"
                  update_status_cm "available" "error" "${PEER_NAME}" "SVM peer creation failed: ${ERR_MSG}"
                fi

                if [ "${HTTP}" = "202" ]; then
                  JOB_UUID=$(echo "${BODY}" | jq -r '.job.uuid // empty')
                  if [ -n "${JOB_UUID}" ]; then
                    echo "  Async job: ${JOB_UUID} - waiting for completion..."
                    RETRIES=0
                    while [ ${RETRIES} -lt 12 ]; do
                      JOB_RESP=$(api "https://${LOCAL_CLUSTER_MGMT}/api/cluster/jobs/${JOB_UUID}")
                      JOB_STATE=$(echo "${JOB_RESP}" | jq -r '.state // "running"')
                      if [ "${JOB_STATE}" = "success" ]; then
                        echo "  SVM peer job completed successfully."
                        break
                      elif [ "${JOB_STATE}" = "failure" ]; then
                        JOB_MSG=$(echo "${JOB_RESP}" | jq -r '.message // "unknown"')
                        echo "  SVM peer job failed: ${JOB_MSG}"
                        update_status_cm "available" "error" "${PEER_NAME}" "SVM peering failed: ${JOB_MSG}"
                        break
                      fi
                      echo "  Job state: ${JOB_STATE} (waiting...)"
                      RETRIES=$((RETRIES + 1))
                      sleep 5
                    done
                  fi
                fi

                sleep 5
                SVM_PEERS=$(api "${SVM_PEERS_URL}")
                SVM_STATE=$(echo "${SVM_PEERS}" | jq -r '.records[0].state // "pending"')
                update_status_cm "available" "${SVM_STATE}" "${PEER_NAME}" "SVM peering initiated"
              fi

              # ---- Step 4: Final Verification ----
              echo ""
              echo "============================================"
              echo "  Peering Status (local view)"
              echo "============================================"
              echo "Cluster peers:"
              api "${CLUSTER_PEERS_URL}" | \
                jq -r '.records[] | "  \(.name): \(.status.state)"'
              echo "SVM peers:"
              SVM_FINAL=$(api "${SVM_PEERS_URL}")
              echo "${SVM_FINAL}" | jq -r '.records[] | "  \(.svm.name) <-> \(.peer.svm.name): \(.state)"'
              echo "============================================"

              FINAL_SVM_STATE=$(echo "${SVM_FINAL}" | jq -r '.records[0].state // "pending"')
              if [ "${FINAL_SVM_STATE}" = "peered" ]; then
                update_status_cm "available" "peered" "${PEER_NAME}" "Cluster and SVM peering fully established"
                echo "  ONTAP peering fully established"
              else
                update_status_cm "available" "${FINAL_SVM_STATE}" "${PEER_NAME}" "SVM peering state: ${FINAL_SVM_STATE}"
                echo "  ONTAP peering (local side) complete, SVM state: ${FINAL_SVM_STATE}"
              fi
              echo "============================================"
          volumeMounts:
            - name: ontap-creds
              mountPath: /credentials
              readOnly: true
      volumes:
        - name: ontap-creds
          secret:
            secretName: {{ .Values.tridentProtect.ontapPeering.secretName }}
{{- end }}
